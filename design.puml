@startuml
package presentation {
+class ANSIColors {
// lots of color constants
}

+class LinterMain {
-saver: Saver
+LinterMain()
-lint(): void
-promptUserForDirectory(): String
-promptUserForOutputFileName(): String
-promptUserForChecks(): String
-validateUserSelectedChecks(checks: String): List<CheckType>
-prettyPrint(errors: List<Error>): void
-saveToFile(message: String): void
}
note left of LinterMain::lint
    calls prettyPrint()
end note
}

package domain {
+class AdapterPattern {
-classNodes: List<MyClassNode>
-classNames: List<String>
-interfaceNames: Set<String>
+AdapterPattern(classNodes: List<MyClassNode>)
-findAdapterPatterns(): List<AdapterPatternClasses>
-getImplementedInterfaces(classNode: ClassNode): List<String>
-getNotJavaClassFieldTypes(classNode: ClassNode): List<String>
-fieldTypeIsClass(fieldType: String): boolean
-findAdapterPatternClients(possibleAdapterPatterns: List<AdapterPatternClasses>): List<AdapterPatternClasses>
-findImplementedInterfaces(className: String): List<String>
-getAdapterPatternClassesForInterface(interfaceName: String,
possibleAdapterPatterns: List<AdapterPatternClasses>, classNode: ClassNode): List<AdapterPatternClasses>
}

-class AdapterPatternClasses {
-adapter: String
-concreteAdapter: String
-adaptee: String
-client: String
-AdapterPatternClasses(concreteAdapter: String, adapter: String, adaptee: String, client: String)
-AdapterPatternClasses(concreteAdapter: String, adapter: String, adaptee: String)
}

+interface Check {
+{abstract}run(classNode: ClassNode): List<Error>
}

+enum CheckType {
HIDDEN_FIELDS,
NAMING_CONVENTIONS,
MAGIC_NUMBERS,
INTERFACE_OVER_IMPLEMENTATION,
COMPOSITION_OVER_INHERITANCE,
PLK,
TEMPLATE,
STRATEGY,
ADAPTER
}

+class ClassNodeCreator {
+createClassNode(path: String): ClassNode
}

+class CompositionOverInheritance implements Check {
-checkForInheritance(): void
}

+class Error {
-lineNumber: int
-checkType: CheckType
-message: String
+Error(lineNumber: int, checkType: CheckType, message: String)
+getLineNumber(): int
+getCheckType(): CheckType
+getMessage(): String
}

+class FinalLocalVariables {
}

+class HiddenFields {
-checkFieldHiding(classNode: ClassNode): List<String>
-{static} reference(classNode: ClassNode): void
}

+class InterfaceOverImplementation {
+InterfaceOverImplementation(classNodeCreator: ClassNodeCreator)
-checkImplementInterface(classNode: ClassNode): List<String>
-implementsOrExtendsClass(fieldClassNode: ClassNode): boolean
-checkIfAbstract(superName: String): boolean
}

+class Linter {
-checkTypeToCheck: Map<CheckType, Check>
-classNodeCreator: ClassNodeCreator
-classNodes: List<ClassNode>
+Linter(classPaths: List<String>, classNodeCreator: ClassNodeCreator)
+runSelectedChecks(List<CheckType>): List<Error>
-createClassNodes(classPaths: List<String>): List<ClassNode>
-createSelectedChecks(List<CheckType>)
}

+class MyASMClassNode implements MyClassNode {
//takes all fields of abstract
(inherits all methods)
}

+class MyASMClassReader implements MyClassReader {
}

+class MyASMFieldNode implements MyFieldNode {
//takes all fields of abstract
(inherits all methods)
}

+abstract MyClassNode {
+name: String
+interfaces: List<String>
+superName: String
+fields: List<MyFieldNode>
+MyClassNode()
}

+interface MyClassReader {
}

+abstract MyFieldNode {
+desc: String
+MyFieldNode()
}

+class NamingConventions implements Check {
-checkClassName(): void
-checkFieldNames(): void
-checkMethodName(): void
-invalidCamelCase(name: String): boolean
-invalidPascalCase(name: String): boolean
}

+class PrincipleOfLeastKnowledge implements Check {
}

+class StrategyPattern {
-classNodeCreator: ClassNodeCreator
+StrategyPattern(classNodeCreator: ClassNodeCreator)
-checkForStrategyPattern(): void
-checkFieldForStrategyPattern(field: FieldNode)
-fieldIsAbstractAndValidClass(name: String, originalClassName: String, fieldName: String): boolean
-fieldIsAbstractType(classNode: ClassNode, originalClassName: String, fieldName: String): boolean
-findSetter(classNode: ClassNode, fieldName: String, fieldType): String
}

+class TemplateMethodPattern implements Check {
-detectTemplateMethod(myClassNode: ClassNode): boolean
-containsAbstractMethodCall(instructions: InsnList, methods: List<MethodNode>): boolean
-isAMethodCall(node: AbstractInsnNode): boolean
}
}

package datasource {
+class ErrorSaver implements Saver {
+saveError(message: String): void
}

+interface Saver {
+{abstract} saveError(message: String): void
}
}

package org.objectweb.asm {
+class ClassNode {
}

+class ClassReader {
}

+class FieldNode {
}
}

AdapterPattern ..> AdapterPatternClasses
AdapterPattern -->"*" MyClassNode
AdapterPattern ..> MyFieldNode

Check ..> Error
Check --> domain.MyClassNode
Check --> domain.MyClassReader

Check <|... AdapterPattern
Check <|... FinalLocalVariables
Check <|... HiddenFields
Check <|... InterfaceOverImplementation
Check <|... StrategyPattern

ClassNodeCreator ..> MyClassNode
ClassNodeCreator ..> MyClassReader

domain.MyASMClassNode --> org.objectweb.asm.ClassNode
domain.MyASMClassNode ..> org.objectweb.asm.ClassNode

domain.MyASMClassReader --> org.objectweb.asm.ClassReader
domain.MyASMClassReader ..> org.objectweb.asm.ClassReader

domain.MyASMFieldNode --> org.objectweb.asm.FieldNode
domain.MyASMFieldNode ..> org.objectweb.asm.FieldNode

Error --> CheckType

Linter --> Check
Linter ..> Check
Linter --> CheckType
Linter ..> CheckType
Linter ..> Error
Linter ..> domain.MyClassNode
Linter ..> domain.MyClassReader
Linter ..> ClassNodeCreator

LinterMain ..> ANSIColors
LinterMain .down.> CheckType
LinterMain .down.> Error
LinterMain .down.> Linter
LinterMain .down.> domain.MyClassNode
LinterMain .down.> domain.MyClassReader
LinterMain ..> ClassNodeCreator
LinterMain -down-> Saver

MyClassNode -->"*" MyFieldNode
@enduml