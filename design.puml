@startuml
package presentation {
    +class ANSIColors {
        // lots of color constants
    }


    +class LinterMain {
        -saver: Saver
        -linter: Linter
        +LinterMain()
        -lint(): void
        -promptUserForDirectory(): String
        -promptUserForOutputFileName(): String
        -promptUserForChecks(): List<LintType>
        -validateUserSelectedChecks(checks: String): List<LintType>
        -prettyPrint(Messages: List<Message>): void
        -saveToFile(message: String): void
    }

    }

package domain {

   package checks{
        +class AdapterPattern {
            -myClassNodes: List<MyClassNode>
            -classNames: List<String>
            -interfaceNames: Set<String>
            +AdapterPattern(classNodes: List<MyClassNode>)
            -findAdapterPatterns(): List<AdapterPatternClasses>
            -getImplementedInterfaces(myClassNode: MyClassNode): List<String>
            -getNotJavaClassFieldTypes(myClassNode: MyClassNode): List<String>
            -fieldTypeIsClass(fieldType: String): boolean
            -findAdapterPatternClients(possibleAdapterPatterns: List<AdapterPatternClasses>): List<AdapterPatternClasses>
            -findImplementedInterfaces(className: String): List<String>
            -getAdapterPatternClassesForInterface(interfaceName: String,
            possibleAdapterPatterns: List<AdapterPatternClasses>, myClassNode: MyClassNode): List<AdapterPatternClasses>
            -createMessages(adapterPatterns: List<AdapterPatternClasses>): List<Message>
        }

         +class AdapterPatternClasses {
                -adapter: String
                -concreteAdapter: String
                -adaptee: String
                -client: String
                +AdapterPatternClasses(concreteAdapter: String, adapter: String, adaptee: String, client: String)
                +AdapterPatternClasses(concreteAdapter: String, adapter: String, adaptee: String)
                +getAdapter(): String
                +getConcreteAdapter(): String
                +getAdaptee(): String
                +getClient(): String
        }

        +interface Check {
            +{abstract}run(classNode: MyClassNode): List<Message>
        }

        +class CompositionOverInheritance{
            +run(classNode: MyClassNode): List<Message>
            -checkForInheritance(): List<Message>
        }

        +class DetectUnusedFields {
           - {final} classNodes: List<MyClassNode>
           - {final} fieldUsageMap: Map<MyFieldNode, Boolean>
           - {final} fieldToClass: Map<MyFieldNode, MyClassNode>
           - {final} nameToFieldNode: Map<String, MyFieldNode>

           + DetectUnusedFields(classNodes: List<MyClassNode>)
           + run(classNode: MyClassNode): List<Message>
           + getNamesToDelete(): List<String>
           - detectAllUnusedFields(classNodes: List<MyClassNode>): void
           - populateFieldMaps(): void
           - generateUnusedMessages(): List<Message>
       }

        +class FinalLocalVariables {
            -{static}{final} STORE_OPCODES
            -localVariables: List<LocalVariableInfo>
            -prevInsnIsLabel: boolean
            -prevInsn: MyAbstractInsnNode

            +FinalLocalVariables()
            +run(classNode: MyClassNode): List<Message>
            -checkMethodForFinalLocalVariables(methodNode: MyMethodNode): void
            -addLocalVariable(methodNode: MyMethodNode): void
            -updateVariableScopes(insn: MyAbstractInsnNode): void
            -setInScopeVariables(insn: MyAbstractInsnNode, localVariables: List<MyLocalVariableNode>): void
            -setOutOfScopeVariables(insn: MyAbstractInsnNode, localVariables: List<MyLocalVariableNode>): void
            -handleValueStored(localVariableInfo: LocalVariableInfo): void
        }

        +class HiddenFields {
            +run(classNode: MyClassNode): List<Message>
            -checkFieldHiding(classNode: MyClassNode): List<Message>
        }

        +class ProgramToInterfaceNotImplementation {
            -myClassNodeCreator: MyClassNodeCreator

            +ProgramToInterfaceNotImplementation(myClassNodeCreator: MyClassNodeCreator)
            +run(classNode: MyClassNode): List<Message>
            -checkImplementInterface(classNode: MyClassNode): List<Message>
            -implementsOrExtendsClass(fieldClassNode: MyClassNode): boolean
            -checkIfAbstract(superName: String): boolean
            -getClassName(desc: String): String
            -isPrimitive(desc: String): boolean
            -isJavaAPIClass(className: String):boolean
            -readJavaDefinedClass(classNode: MyClassNode, classNamePath:String , field:MyFieldNode, invalidUses:List<Message>)
            -readUserDefinedClass(classNode: MyClassNode, classNamePath:String , field:MyFieldNode, invalidUses:List<Message>)

        }

        +class LocalVariableInfo {
            -{final}name: String
            -{final}firstLabel: MyLabel
            -{final}lastLabel: MyLabel
            -{final}index: int
            -isInScope: boolean
            -hasBeenStored: boolean
            -hasBeenStoredOnce: boolean

            +LocalVariableInfo(name: String, firstLabel: MyLabel, lastLabel: MyLabel, index: int)
            +setIsInScope(isInScope: boolean): void
            +setHasBeenStored(hasBeenStored: boolean): void
            +setHasBeenStoredOnce(hasBeenStoredOnce: boolean): void
            +getIsInScope(): boolean
            +getHasBeenStored(): boolean
            +getHasBeenStoredOnce(): boolean
        }

         +class NamingConvention {
            +run(classNode: MyClassNode): List<Message>
            -checkClassName(): void
            -checkFieldNames(): void
            -checkMethodName(): void
            -invalidCamelCase(name: String): boolean
            -invalidPascalCase(name: String): boolean
        }

        +class PrincipleOfLeastKnowledge {
            +run(classNode: MyClassNode): List<Message>
        }

        +class StrategyPattern {
            -myClassNodeCreator: MyClassNodeCreator

            +StrategyPattern(myClassNodeCreator: MyClassNodeCreator)
            +run(classNode: MyClassNode): List<Message>
            -checkForStrategyPattern(): void
            -checkFieldForStrategyPattern(field: MyFieldNode)
            -fieldIsAbstractAndValidClass(name: String, originalClassName: String, fieldName: String): boolean
            -fieldIsAbstractType(myClassNode: MyClassNode): boolean
            -findSetter(myClassNode: MyClassNode, fieldName: String, fieldType): String
        }

        +class TemplateMethodPattern{
            +run(classNode: MyClassNode): List<Message>
            -detectTemplateMethod(myClassNode: ClassNode): List<Message>
            -containsAbstractMethodCall(instructions: <MyAbstractInsnNode>, methods: List<MyMethodNode>): boolean
            -similarAbstractMethodInsn(methodInsNode: MethodInsnNode, methodNode: MyMethodNode):boolean
            -isAMethodCall(node: MyAbstractInsnNode): boolean
        }
    }

    package transformations{
        +class DeleteUnusedFields {
             - modifiedClassNodes: List<ClassNode>
             - outputPath: String
             - byteCodeExporter: Exporter

             + DeleteUnusedFields(path: String)
             + run(classNodes: List<MyClassNode>): List<Message>
             - deleteUnusedFields(classNode: ClassNode, fieldsToDelete: List<String>): ClassNode
             - exportModifiedClassNodes(): List<Message>
        }

        +class FieldsRemover {
             - {final}fieldsToRemove: List<String>
             + FieldsRemover(api: int, cv: ClassVisitor, fieldsToRemove: List<String>)
             + visitField(access: int, name: String, descriptor: String, signature: String, value: Object): FieldVisitor
             + visitMethod(access: int, name: String, descriptor: String, signature: String, exceptions: String[]): MethodVisitor
        }

       -class CustomMethodVisitor {
             - fieldsToRemove: List<String>
             + CustomMethodVisitor(api: int, mv: MethodVisitor, fieldsToRemove: List<String>)
             + visitFieldInsn(opcode: int, owner: String, name: String, descriptor: String): void
       }

       +interface Transformation{
            +{abstract} run(classNodes: List<ClassNode>): List<Message>
       }
    }

    package myasm{
        +class MyASMAbstractInsnNodeFactory{
            +MyASMAbstractInsnNode(abstractInsnNode: AbstractInsnNode)
            +constructTypedInsnNode(insn: AbstractInsnNode): MyAbstractInsnNode
        }
        +class MyASMClassNode{
            -classNode: ClassNode
            //takes all fields of abstract
            +MyASMClassNode(classNode: ClassNode)
        }
        +class MyASMClassReader{
            -classReader: ClassReader

            +MyASMClassReader(classReader: ClassReader)
        }
        +class MyASMFieldNode {
            -fieldNode: FieldNode
            //takes all fields of abstract

            +MyASMFieldNode(fieldNode: FieldNode)
        }
        +class MyASMLabel{
            - label: Label

            +MyASMLabel(label: Label)
        }
        +class MyASMMethodNode{
            -methodNode: MethodNode
            //takes all fields of abstract

            +MyASMMethodNode(methodNode: MethodNode)
            -adaptInstructions(): List<MyAbstractInsnNode>
            -adaptLocalVariables(): List<MyLocalVariableNode>
        }
        +class MyASMLocalVariableNode{
           -localVariableNode: LocalVariableNode
           //takes all fields of abstract

           +MyASMLocalVariableNode(localVariableNode: LocalVariableNode)
           -convertEndLabel(): MyLabelNode
           -convertStartLabel(): MyLabelNode
        }
        +class MyASMLabelNode {
            -labelNode: LabelNode

            +MyASMLabelNode(labelNode: LabelNode)
            (inherits all methods)
        }
        +class MyASMMethodInsnNode{
                // takes all fields of abstract
                - methodInsnNode: MethodInsnNode

                +MyASMMethodInsnNode(methodInsNode: MethodInsnNode)
        }
        +class MyASMVarInsnNode {
            - varInsnNode: VarInsnNode
            //takes all fields of abstract

            +MyASMVarInsnNode(varInsnNode: VarInsnNode)
        }
        +class MyASMFieldInsnNode{
            -fieldInsnNode: FieldInsnNode

            +MyASMFieldInsnNode(fieldInsnNode: FieldInsnNode)
        }
    }

     +class Linter {
        - creator: MyClassNodeCreator
        - myClassNodes: List<MyClassNode>
        - checkTypeToCheck: Map<LintType, Check>
        - transformationTypeToTransformation: Map<LintType, Transformation>

        + Linter(classPaths: List<String>, myClassNodeCreator: MyClassNodeCreator, outputPath: String)
        + runSelectedChecks(lintTypes: Set<LintType>): List<Message>
        + runSelectedTransformations(transformations: Set<LintType>): List<Message>
        - populateTransformMap(outputPath: String): void
        - populateCheckMap(): void
        - createClassNodes(classPaths: List<String>): List<MyClassNode>
        - runCheckOnAllNodes(lintType: LintType): List<Message>
        }

    +enum LintType {
        HIDDEN_FIELDS,
        NAMING_CONVENTIONS,
        MAGIC_NUMBERS,
        INTERFACE_OVER_IMPLEMENTATION,
        COMPOSITION_OVER_INHERITANCE,
        PLK,
        TEMPLATE,
        STRATEGY,
        ADAPTER,
        UNUSED_FIELD
    }

    +class Message {
        -checkType: LintType
        -message: String
        -classOfInterest: String
        +Message(checkType: LintType, classOfInterest: String, message: String)
        +getLintType(): LintType
        +getMessage(): String
        +getClassOfInterest(): String
    }

    +class MyClassNodeCreator {
        +createMyClassNode(path: String): MyClassNode
    }

    +abstract class MyAbstractInsnNode {
        +{static}{final} LABEL: int
        +getNext(): MyAbstractInsnNode
        +getOpcode(): int
        +{abstract}getType(): int

    }

    +abstract class MyClassNode {
        +access: int
        +name: String
        +superName: String
        +interfaces: List<String>
        +fields: List<MyFieldNode>
        +methods: List<MyMethodNode>
    }

    +interface MyClassReader {
    }

    +abstract class MyFieldNode {
        +desc: String
        +name: String
        +access: int
    }

    +interface MyLabel {
    }

    +abstract class MyMethodNode {
        -insnFactory: MyASMAbstractInsnNodeFactory
        +access: int
        +name: String
        +desc: String
        +instructions: List<MyAbstractInsnNode>
        +localVariables: List<MyLocalVariableNode>
    }

    +abstract class MyLocalVariableNode {
        +end: MyLabelNode
        +index: int
        +name: String
        +start: MyLabelNode
    }

    +abstract class MyLabelNode{
        +getLabel(): MyLabel
    }

    +abstract class MyMethodInsnNode{
        +name: String
        +desc: String
    }

    +abstract class MyVarInsnNode {
           +var: int
       }

    +abstract class MyFieldInsnNode{
        +name: String
        +desc: String
    }

    +class MyDefaultInsnNode{

    }

    +interface MyOpcodes {
        + {static}{final} ISTORE: int
        + {static}{final} LSTORE: int
        + {static}{final} FSTORE: int
        + {static}{final} DSTORE: int
        + {static}{final} ASTORE: int
        + {static}{final} INVOKEVIRTUAL: int
        + {static}{final} INVOKEINTERFACE: int
        + {static}{final} INVOKEDYNAMIC: int
        + {static}{final} INVOKESPECIAL: int
        + {static}{final} ACC_ABSTRACT: int
        + {static}{final} ACC_INTERFACE: int
        + {static}{final} ACC_STATIC: int
        + {static}{final} ACC_FINAL: int
        + {static}{final} PUTFIELD: int
        + {static}{final} PUTSTATIC: int
    }
}

package datasource {

    +interface Saver {
        +{abstract} saveMessage(message: String): void
    }
    +class MessageSaver implements Saver {
        +MessageSaver(path:String)
        +saveMessage(message: String): void
    }

    +interface Exporter{
        +save(outputPath: String, className: String, bytecode:  byte[]): void
    }

    +class ByteCodeExporter{

    }
    note left of ByteCodeExporter
        ByteCodeExporter depends on File
        and FIleOutputStream
    end note
    ByteCodeExporter .up.|> Exporter


}

package org.objectweb.asm {
    +class AbstractInsnNode {
    }
    +class ClassNode {
    }
    +class ClassReader {
    }
    +class FieldNode {
    }
    +class Label {
    }
    +class LabelNode {
    }
    +class LocalVariableNode{
    }
    +class MethodInsnNode{
    }
    +class MethodNode {
    }
    +class VarInsnNode {
    }
    +class FieldInsnNode{
    }
   +class MethodVisitor{
   }
   +class ClassVisitor{
   }
   +class MethodVisitor{
   }
   +class ClassWriter{
   }
}

LinterMain ..> ANSIColors
LinterMain ..> LintType
LinterMain ..> Message
LinterMain --> Linter
LinterMain ..> Linter
LinterMain ..> MyClassNodeCreator
LinterMain --> Saver

Linter -> "*"LintType
Linter --> "*"Check
Linter ..> Check
Linter --> MyClassNodeCreator
Linter -> "*" MyClassNode
Linter ..> LintType
Linter .up.> Message
Linter -->"*" Transformation
Linter ...> Transformation


Message --> LintType

MyASMClassNode ..up|> MyClassNode
MyASMClassReader .up|> MyClassReader
MyASMFieldNode -up|> MyFieldNode
MyASMLabel ..up|> MyLabel
MyASMMethodNode ..up|> MyMethodNode
MyASMLabelNode -|> MyLabelNode
MyASMLocalVariableNode -up|> MyLocalVariableNode
MyASMMethodInsnNode ..up|> MyMethodInsnNode
MyMethodInsnNode -up-|> MyAbstractInsnNode
MyASMMethodNode -up-|> MyMethodNode
MyASMVarInsnNode -up|> MyVarInsnNode
MyLabelNode -|> MyAbstractInsnNode
MyVarInsnNode -up-|> MyAbstractInsnNode
MyASMFieldInsnNode -up-|> MyFieldInsnNode
MyFieldInsnNode -up-|> MyAbstractInsnNode
MyDefaultInsnNode -up-|> MyAbstractInsnNode

MyASMAbstractInsnNodeFactory ..> MyAbstractInsnNode
MyMethodNode ..> MyASMAbstractInsnNodeFactory
MyMethodNode --> MyASMAbstractInsnNodeFactory

Check .up> Message
Check --> domain.MyClassNode
Check <|.. AdapterPattern
Check <|.. FinalLocalVariables
Check <|.. PrincipleOfLeastKnowledge
Check <|.. HiddenFields
Check <|.. ProgramToInterfaceNotImplementation
Check <|.. TemplateMethodPattern
Check <|.. StrategyPattern
Check <|.. NamingConvention
Check <|.. CompositionOverInheritance
Check <|.. DetectUnusedFields


MyClassNodeCreator ..> MyClassNode
MyClassNodeCreator ..> MyClassReader

ProgramToInterfaceNotImplementation --> MyClassNodeCreator

StrategyPattern --> MyClassNodeCreator
StrategyPattern ..> MyClassNode
StrategyPattern ..> MyFieldNode
StrategyPattern ..> MyFieldInsnNode
StrategyPattern ..> MyAbstractInsnNode
StrategyPattern ..> MyMethodNode
StrategyPattern ..> MyOpcodes

TemplateMethodPattern ..> MyAbstractInsnNode
TemplateMethodPattern ..> MyMethodNode
TemplateMethodPattern ..> MyClassNode
TemplateMethodPattern ..> Message

CompositionOverInheritance ..> MyClassNode

NamingConvention ..> MyClassNode
NamingConvention ..> MyFieldNode
NamingConvention ..> MyMethodNode
NamingConvention ..> MyOpcodes

AdapterPattern ..> AdapterPatternClasses
AdapterPattern ..> LintType
AdapterPattern -->"*" MyClassNode
AdapterPattern ..> MyFieldNode

FinalLocalVariables -->"*" LocalVariableInfo
FinalLocalVariables ..> LocalVariableInfo
FinalLocalVariables --> MyAbstractInsnNode
FinalLocalVariables --> MyClassNode
FinalLocalVariables ..> MyLabel
FinalLocalVariables ..> MyLabelNode
FinalLocalVariables .....> MyLocalVariableNode
FinalLocalVariables ..> MyMethodNode
FinalLocalVariables -->"*" MyOpcodes
FinalLocalVariables ..> MyVarInsnNode

HiddenFields ..> MyClassNode
HiddenFields ..> Message

ProgramToInterfaceNotImplementation ..> MyClassNode
ProgramToInterfaceNotImplementation ..> MyFieldNode
ProgramToInterfaceNotImplementation --> MyClassNodeCreator
ProgramToInterfaceNotImplementation ..> Message


LocalVariableInfo -->"2" MyLabel

DetectUnusedFields ---> MyClassNode
DetectUnusedFields -> MyFieldNode
DetectUnusedFields -> MyMethodNode
DetectUnusedFields -> MyAbstractInsnNode
DetectUnusedFields -> MyFieldInsnNode

DeleteUnusedFields .up.|> Transformation
DeleteUnusedFields .> org.objectweb.asm.ClassNode
DeleteUnusedFields -> "*"org.objectweb.asm.ClassNode
DeleteUnusedFields .> FieldsRemover
DeleteUnusedFields -> Exporter
DeleteUnusedFields ..> ByteCodeExporter
DeleteUnusedFields ..> org.objectweb.asm.ClassWriter
DeleteUnusedFields .> MyClassNode
DeleteUnusedFields ..> DetectUnusedFields
Transformation .> Message

CustomMethodVisitor -|> org.objectweb.asm.MethodVisitor
CustomMethodVisitor .> org.objectweb.asm.MethodVisitor
FieldsRemover -|> org.objectweb.asm.ClassVisitor
FieldsRemover .> org.objectweb.asm.ClassVisitor
FieldsRemover -> CustomMethodVisitor
FieldsRemover .> CustomMethodVisitor
FieldsRemover ..> org.objectweb.asm.FieldVisitor
FieldsRemover .> org.objectweb.asm.MethodVisitor


MyASMClassNode --> org.objectweb.asm.ClassNode
MyASMClassNode ..> org.objectweb.asm.ClassNode

MyASMClassReader --> org.objectweb.asm.ClassReader
MyASMClassReader ..> org.objectweb.asm.ClassReader

MyASMFieldNode --> org.objectweb.asm.FieldNode
MyASMFieldNode ..> org.objectweb.asm.FieldNode

MyASMLabel --> org.objectweb.asm.Label
MyASMLabel ..> org.objectweb.asm.Label

MyASMLabelNode --> org.objectweb.asm.LabelNode
MyASMLabelNode ..> org.objectweb.asm.LabelNode

MyASMLocalVariableNode -down--> org.objectweb.asm.LocalVariableNode
MyASMLocalVariableNode .down..> org.objectweb.asm.LocalVariableNode

MyASMMethodInsnNode -> org.objectweb.asm.MethodInsnNode
MyASMMethodInsnNode .> org.objectweb.asm.MethodInsnNode

MyASMMethodNode --> org.objectweb.asm.MethodNode
MyASMMethodNode ..> org.objectweb.asm.MethodNode

MyASMVarInsnNode --> org.objectweb.asm.VarInsnNode
MyASMVarInsnNode ..> org.objectweb.asm.VarInsnNode

MyClassNode -->"*" MyFieldNode
MyClassNode -->"*" MyMethodNode

MyLabelNode ..> MyLabel

MyLocalVariableNode -->"2" MyLabelNode

MyMethodNode -->"*" MyLocalVariableNode
MyMethodNode -->"*" MyAbstractInsnNode



@enduml